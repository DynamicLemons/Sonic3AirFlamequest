//# address-hook(0x055df2) end(0x055e48)
function void fn055df2()
{
	// Heat haze effect in foreground
	A1 = 0xffffa810
	A6 = 0x05077e
	D0.u16 = camera.foreground.y.u16
	D1.u16 = 223
	D2.u16 = level.framecounter
	D2.u16 += D0.u16 * 2
	D2.u16 &= 0x3e
	A6 += D2.u16
	D6.s16 = -camera.foreground.x.u16
	fn04f0b6()

	// Heat haze effect in background
	A1 = 0xffffe000		// Location of linewise scroll offsets
	A2 = 0xffffa810
	A4 = (global.zone == 0x03) ? 0x0520fe : 0x0560dc
	A5 = 0xffffa800
	A6 = 0x05077e
	D0.u16 = camera.background.y.u16
	D1.u16 = getScreenHeight() - 1
	D2.u16 = ((level.framecounter) + D0.u16 * 2) & 0x3e
	A6 += D2.u16
	fn04f1f0()
}

function void mhzheathaze()
{
	// Supposedly the heat haze effect
	A1 = 0xffffe000		// Location of linewise scroll offsets
	D1.u16 = level.framecounter * 2 
	A5 = 0x05077e + ((camera.foreground.y.u16 + D1.u16) & 0x3e)
	D1.s16 >>= 1
	A6 = 0x05077e + ((camera.background.y.u16 + D1.u16) & 0x3e)

	D0.u16 = -camera.foreground.x.u16
	D1.u16 = -camera.background.x.u16
	D2.u16 = getScreenHeight()

	while (D2.s16 > 0)
	{
		u16[A1]   = u16[A5] + D0.u16
		u16[A1+2] = u16[A6] + D1.u16
		A1 += 4
		if global.zone_act == 0x0701
		{
		A5 += 4
		A6 += 4		
		}
		else
		{
		A5 += 2
		A6 += 2	
		}

		--D2.s16
	}
}

//# address-hook(0x0529fc) end(0x052a26)
function void fn0529fc()
{
	D1.u16 = u16[0xffffeed6]
	if (D1.u16 != 0)
		D1.u16 = 0x0200

	A6 = 0xffffee90		// Address of camera.background.y
	A5 = 0xffffee96		// Address of camera.background.y.old
	D6 = 0x20
	LoadTileContentInDirY()

	A4 = (u16[0xffffeed6] == 0) ? 0x052d28 : 0x052d6e
	A5 = 0xffffa800
	fn055df2()
}

//# address-hook(0x0530ba) end(0x0530e8)
function void fn0530ba()
{
	D1.u16 = u16[0xffffeed6]
	if (D1.u16 != 0)
		D1.u16 = 0x0200

	A6 = 0xffffee90		// Address of camera.background.y
	A5 = 0xffffee96		// Address of camera.background.y.old
	D6 = 0x20
	LoadTileContentInDirY()

	A4 = (u16[0xffffeed6] == 0) ? 0x052d28 : 0x052d6e
	A5 = 0xffffa800
	fn055df2()
	UpdateScreenShake()
}

//# address-hook(0x050bce) end(0x050c48)
function void fn050bce()
{
	if (u16[0xffffeec6] != 0)
	{
		u16[0xffffeec6] = 0

		u32 backupD7 = D7
		u32 backupA0 = A0
		u32 backupA2 = A2
		u32 backupA3 = A3

		Kosinski.addToDecompressionQueue(0x3c18ee, 0xffff0a00)
		Kosinski.addToDecompressionQueue(0x3bf17c, 0xffff9558)

		Kosinski.addToDMAQueue(0x3bfa6c, 0x2360)

		requestLoadingPatterns(0x10)
		requestLoadingPatterns(0x11)

		D7 = backupD7
		A0 = backupA0
		A2 = backupA2
		A3 = backupA3

		u8[0xffffeee8] = 0xff
		level.scrolling_routine += 4
	}

	UpdateBackground.HCZ1()

	A6 = 0xffffee90		// Address of camera.background.y
	A5 = 0xffffee96		// Address of camera.background.y.old
	D1 = 0
	D6 = 0x20
	LoadTileContentInDirY()

	A4 = 0x23c590
	A5 = 0xffffa800
	fn055df2()
}

//# address-hook(0x050c4c) end(0x050cfa)
function void fn050c4c()
{
	if (kosinski.waiting_modules == 0)
	{
		global.zone_act = 0x0101
		camera.update_routine = 0
		dynobjects.routine = 0
		rings.update_routine = 0
		level.boss_encounter = 0
		global.in_extra_stage = 0
		fn04f8f8()

		u32[0xffffb172] = 0x0383bc		// HCZ run-on-water handler
		u8[0xffffb19e] = 0x01

		u32 backupD7 = D7
		u32 backupA0 = A0
		u32 backupA2 = A2
		u32 backupA3 = A3

		fn01c362()
		fn0076a6()
		Level.InitializeWater()

		D0.u16 = 0x06a0
		water.height.current = D0.u16
		water.height.next = D0.u16
		water.height.target = D0.u16

		Level.loadPaletteData(0x0d)

		D7 = backupD7
		A0 = backupA0
		A2 = backupA2
		A3 = backupA3

		D0.u16 = 0x3600
		D1 = 0
		u16[0xffffb010] -= D0.u16
		u16[0xffffb05a] -= D0.u16
		fn04f3b0()

		camera.position.x.u16 -= D0.u16
		camera.foreground.x.u16 -= D0.u16
		move_area.left -= D0.u16
		move_area.right -= D0.u16
		Level.GetCameraPosition()

		level.scrolling_routine = 0
	}

	UpdateBackground.HCZ1()

	A6 = 0xffffee90		// Address of camera.background.y
	A5 = 0xffffee96		// Address of camera.background.y.old
	D1 = 0
	D6 = 0x20
	LoadTileContentInDirY()

	A4 = 0x23c590
	A5 = 0xffffa800
	fn055df2()
}

//# address-hook(0x050fce) end(0x050fec)
function void fn050fce()
{
	A6 = 0xffffee90		// Address of camera.background.y
	A5 = 0xffffee96		// Address of camera.background.y.old
	D1 = 0
	D6 = 0x20
	LoadTileContentInDirY()

	A4 = 0x23c7d2
	A5 = 0xffffa800
	fn055df2()
	UpdateScreenShake()
}

//# address-hook(0x051caa) end(0x051d16)
function void fn051caa()
{
#if STANDALONE
	if (camera.position.x.u16 >= 0x3000 - getScreenExtend() && (camera.position.y.u16 < 0x280 || camera.position.y.u16 >= 0x880))
	{
		// Lock screen here so nobody can get to see the ugly parts to the left
		move_area.left = 0x2f80
#else
	if (camera.position.x.u16 >= 0x3000 - getScreenExtend())
	{
#endif
		if (camera.position.y.u16 >= 0x054c)
		{
			// When taking Knuckles' path, move everything up to Sonic's path
			D0.u16 = 0x0700
			u16[0xffffb014] -= D0.u16
			u16[0xffffb05e] -= D0.u16
			camera.position.y.u16 -= D0.u16
			camera.foreground.y.u16 -= D0.u16
			Level.GetCameraPosition()
		}

		fn051fa4()
		fn04f2f6()

		loadPaletteLine1(0x06e370)

		D0.u16 = 0x01c0
		level.vertical_wrap = D0.u16
		knuckles.preventclimbing |= 0x80
		level.scrolling_routine += 4
		fn051d26()
	}
	else
	{
		UpdateBackground.CNZ1()

		A6 = 0xffffee90		// Address of camera.background.y
		A5 = 0xffffee96		// Address of camera.background.y.old
		D1 = 0
		D6 = 0x20
		LoadTileContentInDirY()

		A4 = 0x0520fe
		A5 = 0xffffa800
		fn055df2()
	}
}

//# address-hook(0x052280) end(0x05229c)
function void fn052280()
{
	A6 = 0xffffee90		// Address of camera.background.y
	A5 = 0xffffee96		// Address of camera.background.y.old
	D1 = 0
	D6 = 0x20
	LoadTileContentInDirY()

	A4 = 0x0520fe
	A5 = 0xffffa800
	fn055df2()
	UpdateScreenShake()
}

//# address-hook(0x053780) end(0x0537a4)
function void fn053780()
{
	fn053940()

	A6 = 0xffffee90		// Address of camera.background.y
	A5 = 0xffffee96		// Address of camera.background.y.old
	D1.u16 = 0x1880
	D6 = 0x20
	LoadTileContentInDirY()

	A4 = 0x23defa
	A5 = 0xffffa800
	fn055df2()
	UpdateScreenShake()
}

//# address-hook(0x053d60)
//# address-hook(0x053d78) end(0x053e58)
function void fn053d78()
{
	// This function updates both foreground and background x-scrolling

	// Switch between indoors and outdoors if necessary
	bool indoors = (u16[0xffffeee8] != 0)
	if (!indoors)
	{
		D0.u16 = camera.position.x.u16
		if (D0.u16 >= 0x1000 && D0.u16 < 0x3600)
		{
			if (camera.position.y.u16 >= 0x0720)
			{
				// Switch to indoors
				fn053d96()
				return
			}
		}

		UpdateBackgroundScrolling.ICZ2.Outdoors()
	}
	else
	{
		D0.u16 = camera.position.x.u16
		if (D0.u16 >= 0x1000 && D0.u16 < 0x3600)
		{
			if (D0.u16 < 0x1900 || D0.u16 >= 0x1b80)
			{
				if (camera.position.y.u16 < 0x0720)
				{
					// Switch to outdoors
					fn053dfc()
					return
				}
			}
		}

		UpdateBackgroundScrolling.ICZ2.Indoors()

		A6 = 0xffffee90		// Address of camera.background.y
		A5 = 0xffffee96		// Address of camera.background.y.old
		D1 = 0
		D6 = 0x20
		LoadTileContentInDirY()
	}

	A4 = indoors ? 0x23e246 : 0x23e23e
	A5 = 0xffffa800
	fn055df2()

#if STANDALONE
	// Limit movement to where the boss area ends, to prevent Knuckles from gliding over the upper boss and into Act 2
	//  -> This can safely applied for the lower boss as well, as it's using the same x-positions
	if (global.zone_act == 0x0501 && global.zone_act.apparent == 0x0500 && move_area.right == 0x7000)
	{
		move_area.right = 0x06f0
	}
#endif
}

//# address-hook(0x053e3e)
function void fn053e3e()
{
	A6 = 0xffffee90		// Address of camera.background.y
	A5 = 0xffffee96		// Address of camera.background.y.old
	D1 = 0
	D6 = 0x20
	LoadTileContentInDirY()

	A4 = 0x23e246
	A5 = 0xffffa800
	fn055df2()
}

//# address-hook(0x23e0c2) end(0x23e138)
function void UpdateBackgroundScrolling.ICZ2.Outdoors()
{
	camera.background.y.u16 = 0

	// Parallax effect of moving ice
	D0.u16 = 0
	D0 = (D0 & 0xff) << 15
	D1 = D0 >> 6
	D2 = 0

#if STANDALONE
	if (getScreenWidth() > 320)
	{
		while (D2 < 80)
		{
			u16 offset = D0 >> 16

			// Making this effect work in widescreen requires usage of some special renderer effects
			u16 lineNumber = 175 - D2 / 2
			u16 patternWidth = 128 - D2		// Between 50 and 128
			offset = (offset - getScreenExtend() + patternWidth * 2) % patternWidth

			// "offset" will contain scroll offset for left side, while right side scroll offset is passed directly to renderer
			u16 rightSideOffset = offset - patternWidth * (320 / patternWidth)
			Renderer.setScrollOffsetH(2, lineNumber, rightSideOffset)

			u16[0xffffa862 - D2] = offset
			D0 -= D1
			D2 += 2
		}

		Renderer.enableDefaultPlane(0, false)
		Renderer.setupPlane(0, 0, 320, getScreenHeight(), 0x00, 0, 0x1000)
		Renderer.setupPlane(320, 0, getScreenWidth() - 320, getScreenHeight(), 0x00, 2, 0x1000)
	}
	else
#endif
	{
		while (D2 < 80)
		{
			u16[0xffffa862 - D2] = (D0 >> 16)
			D0 -= D1
			D2 += 2
		}
	}

	// Water sparkle a bit further away
	A1 = 0xffffa800
	D0 = u32(camera.foreground.x.u16) << 16
	D0.s32 >>= 1
	D1 = D0
	D0.s32 >>= 1
	D1 += D0
	u32[A1 + 0x64] = D1
	D0.s32 >>= 2
	D1 = D0
	u16[(A1+=2)-2] = D0 >> 16
	D0 += D1
	D0 = (D0 << 16) + (D0 >> 16)
	u16[(A1+=2)-2] = D0.u16
	D1.u16 = (level.framecounter >> 2) & 0x3e
	A5 = 0x23be5a + D1.u16
	D1 = 8
	while (D1 > 0)
	{
		D2.u16 = u16[(A5+=2)-2]
		D2.u16 += D0.u16
		u16[(A1+=2)-2] = D2.u16
		--D1
	}
}

//# address-hook(0x0566a8) end(0x0566b6)
function void fn0566a8()
{
	A6 = 0xffffee90		// Address of camera.background.y
	A5 = 0xffffee96		// Address of camera.background.y.old
	D1.u16 = 0x0200
	D6 = 0x20
	LoadTileContentInDirY()
	fn055df2()
}

//# address-hook(0x05705c) end(0x05707c)
function void fn05705c()
{
	A6 = 0xffffee90		// Address of camera.background.y
	A5 = 0xffffee96		// Address of camera.background.y.old
	D1 = 0
	D6 = 0x20
	LoadTileContentInDirY()

	A4 = 0x057184
	A5 = 0xffffa800
	fn055df2()
	UpdateScreenShake()
}

//# address-hook(0x05a262) end(0x05a282)
function void fn05a262()
{
	A4 = 0x05a39c
	A5 = 0xffffa800
	D6 = 0x20
	D5 = 2
	fn04edf6()

	A4 = 0x05a3a0
	A5 = 0xffffa808
	fn055df2()
	UpdateScreenShake()
}

//# address-hook(0x056c30) end(0x056c68)
function void fn056c30()
{
	A4 = 0x056f68
	A5 = 0xffffa800
	D6 = 0x20
	D5 = 3
	fn055df2()

	D0 = u32[0xffffeed4]
	if (D0 != 0)
	{
		camera.background.y.u16 = D0.u16
		D0 = (D0 << 16) + (D0 >> 16)
		camera.background.x.u16 = D0.u16
		WriteScrollOffsets()
	}
	else
	{
		A4 = 0x056f6e
		A5 = 0xffffa80c
		fn055df2()
	}
	UpdateScreenShake()
}

//# address-hook(0x056d16) end(0x056d3a)
function void fn056d16()
{
	UpdateBackground.LRZ1()
	A4 = 0x056f68
	A5 = 0xffffa800
	D6 = 0x20
	D5 = 0x03
	fn04edf6()

	A4 = 0x056f6e
	A5 = 0xffffa80c
	fn055df2()
	UpdateScreenShake()
}

//# address-hook(0x054bc2) end(0x054c64)
function void UpdateLevelScrolling.MHZ1()
{
	if (u16[0xffffeec6] != 0)
	{
		u16[0xffffeec6] = 0

		push(A3)
		push(A2)
		push(A0)
		push(D7)

		requestLoadingPatterns(0x28)

		global.zone_act = 0x0701
		camera.update_routine = 0
		dynobjects.routine = 0
		rings.update_routine = 0
		level.boss_encounter = 0
		global.in_extra_stage = 0
		fn04f8f8()
		fn01c362()
		fn0076a6()

		D7 = pop()
		A0 = pop()
		A2 = pop()
		A3 = pop()

		D0.u16 = 0x4200
		D1 = 0
		u16[0xffffb010] -= D0.u16
		u16[0xffffb05a] -= D0.u16

		fn054cf4()

		camera.position.x.u16 -= D0.u16
		camera.foreground.x.u16 -= D0.u16
		u16[0xffffeeb4] = camera.foreground.x.u16
		move_area.left -= D0.u16
		move_area.right -= D0.u16

		Level.GetCameraPosition()

		level.special_scrolling = 0
		u8[0xffffeed2] = 0
	}

	A1 = 0xffffeeb4
	D0.u16 = camera.foreground.x.u16
	D2.u16 = 0x0100
	D3.u16 = 0x0200
	fn04f368()
	fn054c68()

	A6 = 0xffffee90		// Address of camera.background.y
	A5 = 0xffffee96		// Address of camera.background.y.old
	D1 = 0
	D6 = 0x20

	LoadTileContentInDirY()
	mhzheathaze()
}

//# address-hook(0x0552e4) end(0x0552f4)
function void fn0552e4()
{
	A6 = 0xffffee90		// Address of camera.background.y
	A5 = 0xffffee96		// Address of camera.background.y.old
	D1 = 0
	D6 = 0x20
	LoadTileContentInDirY()
	mhzheathaze()
}

//# address-hook(0x05550c) end(0x05560a)
function void fn05550c()
{
	#if STANDALONE
		if ((u8[0xffffeed2] | u8[0xffffeed3]) != 0)
		{
			// Split plane A (non-prio) so we can assign to upper part a lower render queue,
			//  which is needed to enable the background blur for that part
			Renderer.enableDefaultPlane(1, false)
			Renderer.setupPlane(0, 0, getScreenWidth(), 48, 0x01, 1, 0x1200)
			Renderer.setupPlane(0, 48, getScreenWidth(), 176, 0x01, 1, 0x2000)
		}
	#endif

	fn055df2()
	if (u16[0xffffeec0] == 0x10)
	{
		D0.s16 = -s16[0xffffa800]
		for (u8 i = 0; i< 0x80; ++i)
		{
			u16[0xffffe000 + i*4] = D0.u16
		}
	}
	else
	{
		if (u8[0xffffeed2] != 0)
		{
			D0.s16 = -s16(camera.background.x.u16)
			for (u8 i = 0; i< 0x30; ++i)
			{
				u16[0xffffe000 + i*4] = D0.u16
			}
		}

		if (u8[0xffffeed3] != 0)
		{
			s16 foregroundOffset = camera.position.x.u16 - 0x4180
			if (foregroundOffset >= -getScreenWidth())
			{
				// Foreground offset jumps to -0x100 when reaching at least 0x100
				//  -> Background offset is the same, but scaled by (0xac / 0x100)
				s16 backgroundOffset = s32(s32(foregroundOffset) * 0xac00) >> 16

				// D1.s32 is the parallax offset of background objects relative to foreground objects
				D1.s32 = (s32(foregroundOffset - backgroundOffset - 0x18) << 16) / 0x30

				A1 = 0xffffe002
				D0 = (0x80 - camera.foreground.x.u16) << 16
				for (u8 i = 0; i < 0x30; ++i)
				{
					u16[A1+i*4] = (D0 >> 16)
					D0 += D1
				}

			#if STANDALONE
				if (getScreenWidth() > 320)
				{
					// Stop the effect when the fight is over
					if (u16[0xffffeedc] == 0 || camera.position.x.u16 <= 0x4180)
					{
						Renderer.enableDefaultPlane(2, false)
						if (foregroundOffset >= -0x100)
							Renderer.setupPlane(0, 0, 320, getScreenHeight(), 0x10, 0, 0x3000)
						Renderer.setupPlane(320, 0, getScreenWidth() - 320, getScreenHeight(), 0x10, 2, 0x3000)

						for (u8 line = 0; line < 0x30; ++line)
						{
							u16 scrollOffset = u16[A1+line*4] & 0x1ff
							scrollOffset = -scrollOffset
							if (D0 < 0xbf000000)
								scrollOffset -= (0x100 - u32(0x54) * line / 0x30) * 2	// The last part is the repetition offset
							Renderer.setScrollOffsetH(2, line, scrollOffset & 0x1ff)
						}
					}
				}
			#endif

				// Parallax scrolling for objects (spiked balls and pole behind them) in boss fight
				A1 = 0xffffa808
				A5 = 0xffffe0be
				D0 = 0x1c
				D1 = 6
				while (D1.s16 >= 0)
				{
					D2.u16 = u16[A1]
					if (D2.u16 == 0)
						break

					// RAM address of the object
					A6 = 0xffff0000 + D2.u16

					u16 px = camera.position.x.u16
				#if STANDALONE
					if (u16[A5] < 0xc000)
					{
						s16 screenPosition = ((u16[A5]) & 0x01ff) - 0x48
						px += screenPosition

						// Preparation for rendering of next objects
						u16 parallaxLayer = u16(A5 - 0xffffe002) / 4
						u16 repetitionOffset = (0x100 - u32(0x54) * parallaxLayer / 0x30) * 2

						// Abuse "groundspeed" which is not used otherwise to store the repetition offset
						u16[A6 + 0x1c] = repetitionOffset
					}
					else
					{
						// Do not render yet (to solve a small glitch at start)
						u16[A6 + 0x1c] = 0
					}
				#else
					px += ((u16[A5] - 0x48) & 0x01ff)
				#endif
					u16[A6 + 0x10] = px

					if ((D1 & 0x01) == 0)
					{
						A5 -= D0.u16
						D0.u16 += 0x0c
					}

					A1 += 2
					--D1.s16
				}
			}
			else
			{
				A1 = 0xffffe002
				D0 = 0x2f
				while (D0.s16 >= 0)
				{
					u16[A1] = 0
					A1 += 4
					--D0.s16
				}
			}
		}
	}
}