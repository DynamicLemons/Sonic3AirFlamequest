// TODO: Remove this in favor of using HSL functions to change character
// paletes dynamically
function u64 getCharacterPaletteKey(u8 character)
{
	bool isBonusStage = (global.zone >= 0x13 && global.zone <= 0x15)

	// TODO: Restore this function to vanilla and use the HSL functions to
	// generate palettes instead

	// Current zone
	bool isCorrectZone = (!isBonusStage) && (global.zone.apparent != 0x00) && !(global.zone.apparent >= 0x0a && global.zone.apparent <= 0x0c)

	// Character and current state
	u64 characterString = (character == CHARACTER_SONIC) ? "sonic" : ((character == CHARACTER_TAILS) ? "tails" : "knuckles")
	u64 characterForm = (super.active & 0x80 || super.active.tails & 0x80) ? "scorching" : "burning"
	u64 characterTemp = isCorrectZone ? "hot" : "normal"

	if(character != CHARACTER_KNUCKLES)
		return stringformat("character_palette_%s_%s_%s", characterForm, characterString, characterTemp)
	else
		return "character_palette_knuckles"

	/* Legacy Code
	if ((!isBonusStage) && (global.zone.apparent != 0x00) && !(global.zone.apparent >= 0x0a && global.zone.apparent <= 0x0c))
	{


		if (character == CHARACTER_SONIC)
		{
			if (super.active & 0x80 || super.active.tails & 0x80)
			{
				return "character_palette_scorching_sonic_hot"
			}
			else
			{
				return "character_palette_burning_sonic_hot"
			}
		}
		else if (character == CHARACTER_TAILS)
		{
			if (super.active & 0x80 || super.active.tails & 0x80)
			{
				return "character_palette_scorching_tails_hot"
			}
			else
			{
				return "character_palette_burning_tails_hot"
			}
		}
		else if (character == CHARACTER_KNUCKLES)
		{
			if (super.active & 0x80 || super.active.tails & 0x80)
			{
				return "character_palette_scorching_knuckles_hot"
			}
			else
			{
				return "character_palette_burning_knuckles_hot"
			}
		}

	}
	else
	{
		if (character == CHARACTER_SONIC)
		{
			if (super.active & 0x80 || super.active.tails & 0x80)
			{
				return "character_palette_scorching_sonic_normal"
			}
			else
			{
				return "character_palette_burning_sonic_normal"
			}
		}
		else if (character == CHARACTER_TAILS)
		{
			if (super.active & 0x80 || super.active.tails & 0x80)
			{
				return "character_palette_scorching_tails_normal"
			}
			else
			{
				return "character_palette_burning_tails_normal"
			}
		}
		else if (character == CHARACTER_KNUCKLES)
		{
			if (super.active & 0x80 || super.active.tails & 0x80)
			{
				return "character_palette_scorching_knuckles_normal"
			}
			else
			{
				return "character_palette_burning_knuckles_normal"
			}
		}
	}
	*/
}

// Load Knux' palette into RAM as HSL for palette shenanigans
// In the RGB Knux mod, this will also check for mods w/ RGB Knux compatibility,
// but since FQ isn't that I'll forgo the checks for now
function void loadCharacterPalette(u8 character, u32 targetAddress, u8 paletteVariant)
{
	// Run the vanilla palette loading code
	base.loadCharacterPalette(character, targetAddress, paletteVariant)

	// Load knux palettes
	if(character == CHARACTER_KNUCKLES)
	{
		// Get palette address based on palette variant
		u32 paletteAddress = (!paletteVariant ? FlameQuest.RGB_KNUX_PALETTE : FlameQuest.RGB_KNUX_PALETTE_WATER)

		if(EXTENDED_CHARACTER_PALETTES)
		{
			// The vanilla palette loading code uses shared memory to store colors,
			// so we can use this to easily convert all of Knux' colors to HSL
			for (u8 i = 0; i < 0x20; ++i)
			{
				u32 rgba = u32[0x800000 + i * 4]
				u32[paletteAddress + i * 4] = DKoC.Util.abgrToHSL(rgba)
			}

		}
		// Vanilla palette loading.
		else
		{
			// Copy and unpack colors from ROM
			for(u8 i = 0; i < 0x10; i++)
			{
				u32 rgba = unpackColor(u16[0x0a8afc + i * 2])
				u32[paletteAddress + i * 4] = DKoC.Util.abgrToHSL(rgba)
			}
		}
	}
}

// Palette Effects function
function void UpdatePaletteEffects()
{
	base.UpdatePaletteEffects()

	// Handle RGB Knux stuff
	if(getMainCharacter() == CHARACTER_KNUCKLES && FlameQuest.Secret.useRGBKnux)
	{
		FlameQuest.Character.updateRGBKnux()
	}
}

///////////////////////////////
/// 		RGB KNUX 		///
///////////////////////////////

// Function that updates RGB Knux
function void FlameQuest.Character.updateRGBKnux()
{
	#if !GAMEAPP
	debugLog("Using RGB Knux")
	#endif

	FlameQuest.Character.updateSuperRGBKnux()

	// Normal Knux
	FlameQuest.RGBKnux.updateGameplayRGBKnuxColors(FlameQuest.RGB_KNUX_PALETTE, 0x802080, 32)

	// Underwater Knux
	FlameQuest.RGBKnux.updateGameplayRGBKnuxColors(FlameQuest.RGB_KNUX_PALETTE_WATER, 0x802380, 32)

	/* Old codeing
	for(u8 i = 1; i < 32; i++)
	{
		// Choose how much to shift the color by
		u16 shiftDegree = super.active == 0xff ? 8 : (super.active ? 4 : 1)

		// Shift current color
		u32[FlameQuest.RGB_KNUX_PALETTE + i * 4] = DKoC.Util.shiftHSL(u32[FlameQuest.RGB_KNUX_PALETTE + i * 4], shiftDegree)

		// Get current color & apply any RGB Knux luminance shifting
		u32 hslColor = u32[FlameQuest.RGB_KNUX_PALETTE + i * 4]

		hslColor = DKoC.Util.modifyHSLLuminance(hslColor, FlameQuest.RGBKnux.superGlowOffset)

		// Convert color to RGB
		u32 rgbColor = DKoC.Util.hslToABGR(hslColor)

		u16[ + i * 2] = packColor(rgbColor)

		// Renderer.setPaletteEntry(0x80 + i, rgbColor)
	}

	// Underwater Knux
	for(u8 i = 1; i < 32; i++)
	{
		// Shift current color
		u32[FlameQuest.RGB_KNUX_PALETTE_WATER + i * 4] = DKoC.Util.shiftHSL(u32[FlameQuest.RGB_KNUX_PALETTE_WATER + i * 4], shiftDegree)


		u32 hslColor = u32[FlameQuest.RGB_KNUX_PALETTE_WATER + i * 4]

		hslColor = DKoC.Util.modifyHSLLuminance(hslColor, FlameQuest.RGBKnux.superGlowOffset)

		// Convert color to RGB
		u32 rgbColor = DKoC.Util.hslToABGR(hslColor)


		u16[0x802380 + i * 2] = packColor(rgbColor)

		// Renderer.setPaletteEntry(0x80 + i, rgbColor)
	}*/
}

/* Updates RGB Knux colors
 *
 * u32 sourceAddress - 		Address of RGB Knux palette in RAM
 * u32 destinationAddress - Address in CRAM for RGB Knux palette
 * u8  numColors - 			Number of colors to write to CRAM
 * s16 shiftDegree - 		Degree to shift colors by (see colors.lemon for details)
 */
function void FlameQuest.RGBKnux.updateRGBKnuxColors(u32 sourceAddress, u32 destinationAddress, u8 numColors, s16 shiftDegree)
{
	for(u8 i = 1; i < numColors; i++)
	{
		// Shift current color
		u32[sourceAddress + i * 4] = DKoC.Util.shiftHSL(u32[sourceAddress + i * 4], shiftDegree)

		// Get current color & apply any RGB Knux luminance shifting
		u32 hslColor = u32[sourceAddress + i * 4]
		hslColor = DKoC.Util.modifyHSLLuminance(hslColor, FlameQuest.RGBKnux.superGlowOffset)

		// Convert color to RGB
		u32 rgbColor = DKoC.Util.hslToABGR(hslColor)

		u16[destinationAddress + i * 2] = packColor(rgbColor)

		// Renderer.setPaletteEntry(0x80 + i, rgbColor)
	}
}

// Same as RGBKnux.updateRGBKnuxColors() but uses super.active to determine
// shift degree.
function void FlameQuest.RGBKnux.updateGameplayRGBKnuxColors(u32 sourceAddress, u32 destinationAddress, u8 numColors)
{
	// Choose how much to shift the color by
	u16 shiftDegree = super.active == 0xff ? 8 : (super.active ? 4 : 1)

	FlameQuest.RGBKnux.updateRGBKnuxColors(sourceAddress, destinationAddress, numColors, shiftDegree)
}

// Update Super RGB Knux specific stuff (i.e. palettes)
function void FlameQuest.Character.updateSuperRGBKnux()
{
	// Update RGB Knux' super glow
	if(super.active)
	{
		if(FlameQuest.RGBKnux.superGlowIsIncreasing)
			FlameQuest.RGBKnux.superGlowOffset += (super.active == 0xff ? 6 : 3)
		else
			FlameQuest.RGBKnux.superGlowOffset -= (super.active == 0xff ? 6 : 3)
		/*
		FlameQuest.RGBKnux.superGlowOffset = abs(0x67 - super.palettefx.frame)

		if(super.active != 0xff)
			FlameQuest.RGBKnux.superGlowOffset /= 2
		*/

		// Prevent glow offset from becoming too large (or small)
		FlameQuest.RGBKnux.superGlowOffset = clamp(FlameQuest.RGBKnux.superGlowOffset, 0, 64)

		// If either boundary was hit, switch between increasing/decreasing mode
		if(FlameQuest.RGBKnux.superGlowOffset == 64)
		{
			FlameQuest.RGBKnux.superGlowIsIncreasing = false
		}
		else if(FlameQuest.RGBKnux.superGlowOffset == 0)
		{
			FlameQuest.RGBKnux.superGlowIsIncreasing = true
		}
	}
	else
	{
		if(FlameQuest.RGBKnux.superGlowOffset)
		{
			FlameQuest.RGBKnux.superGlowOffset -= 3

			if(FlameQuest.RGBKnux.superGlowOffset < 0)
				FlameQuest.RGBKnux.superGlowOffset = 0
		}
	}
}

// RGB Knux Outro

// Load RGB Knux palette into RAM
//# address-hook(0x05f480) end(0x05f4e2)
function void fn05f480()
{
	base.fn05f480()

	for(u8 i = 0; i < 0x10; i++)
	{
		// Extract color from CRAM
		u32 colorAddress = 0xfffffc00 + i * 0x02
		u32 rgba = unpackColor(u16[colorAddress])

		// Write to RGB Knux CRAM
		u32[FlameQuest.RGB_KNUX_OUTRO_PALETTE + i * 0x04] = DKoC.Util.abgrToHSL(rgba)
	}
}

// Apply RGB Knux effect to outro RGB Knux
//# address-hook(0x05fba0) end(0x05fbe0)
function void fn05fba0()
{
	if(FlameQuest.Secret.useRGBKnux)
	{
		if (u8[0xfffff650] != 0)
		{
			fn05ec36()
			return
		}
		else
		{
			FlameQuest.RGBKnux.updateOutroRGBKnux()
		}
	}
	else
	{
		base.fn05fba0()
	}
}

// Updates outro RGB Knux
function void FlameQuest.RGBKnux.updateOutroRGBKnux()
{
	// Should never be run during bad outro, therefore
	// outro.ending_type == 2 implies hyper, otherwise Super
	u16 shiftDegree = outro.ending_type ? 8 : 4

	// RGB Knux stuff
	FlameQuest.Character.updateSuperRGBKnux()
	FlameQuest.RGBKnux.updateRGBKnuxColors(FlameQuest.RGB_KNUX_OUTRO_PALETTE, 0xfffffc00, 0x10, shiftDegree)

	/*
	for(u8 i = 0; i < 0x10; i++)
	{

		// Hue shift
		color = DKoC.Util.shiftHSL(color, shiftDegree)

		// Glow Effect
		color = DKoC.Util.modifyHSLLuminance(color, FlameQuest.RGBKnux.superGlowOffset)

		u32 newColorABGR = DKoC.Util.hslToABGR(color)

		// Update color
		Renderer.setPaletteEntry(i, newColorABGR)

		/*
		if(color != 0)
			u32[colorAddress] = DKoC.Util.packColor(newColorABGR, false)


		debugLog(stringformat("%08x > %08x | %08x > %04x >%04x", rgba, color, newColorABGR, DKoC.Util.packColor(newColorABGR, false), u16[colorAddress]))
	}*/
}
