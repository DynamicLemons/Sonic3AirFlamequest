function u64 getCharacterPaletteKey(u8 character)
{
	bool isBonusStage = (global.zone >= 0x13 && global.zone <= 0x15)

	// TODO: Restore this function to vanilla and use the HSL functions to
	// generate palettes instead

	// Current zone
	bool isCorrectZone = (!isBonusStage) && (global.zone.apparent != 0x00) && !(global.zone.apparent >= 0x0a && global.zone.apparent <= 0x0c)

	// Character and current state
	u64 characterString = (character == CHARACTER_SONIC) ? "sonic" : ((character == CHARACTER_TAILS) ? "tails" : "knuckles")
	u64 characterForm = (super.active & 0x80 || super.active.tails & 0x80) ? "scorching" : "burning"
	u64 characterTemp = isCorrectZone ? "hot" : "normal"

	return stringformat("character_palette_%s_%s_%s", characterForm, characterString, characterTemp)

	/* Legacy Code
	if ((!isBonusStage) && (global.zone.apparent != 0x00) && !(global.zone.apparent >= 0x0a && global.zone.apparent <= 0x0c))
	{


		if (character == CHARACTER_SONIC)
		{
			if (super.active & 0x80 || super.active.tails & 0x80)
			{
				return "character_palette_scorching_sonic_hot"
			}
			else
			{
				return "character_palette_burning_sonic_hot"
			}
		}
		else if (character == CHARACTER_TAILS)
		{
			if (super.active & 0x80 || super.active.tails & 0x80)
			{
				return "character_palette_scorching_tails_hot"
			}
			else
			{
				return "character_palette_burning_tails_hot"
			}
		}
		else if (character == CHARACTER_KNUCKLES)
		{
			if (super.active & 0x80 || super.active.tails & 0x80)
			{
				return "character_palette_scorching_knuckles_hot"
			}
			else
			{
				return "character_palette_burning_knuckles_hot"
			}
		}

	}
	else
	{
		if (character == CHARACTER_SONIC)
		{
			if (super.active & 0x80 || super.active.tails & 0x80)
			{
				return "character_palette_scorching_sonic_normal"
			}
			else
			{
				return "character_palette_burning_sonic_normal"
			}
		}
		else if (character == CHARACTER_TAILS)
		{
			if (super.active & 0x80 || super.active.tails & 0x80)
			{
				return "character_palette_scorching_tails_normal"
			}
			else
			{
				return "character_palette_burning_tails_normal"
			}
		}
		else if (character == CHARACTER_KNUCKLES)
		{
			if (super.active & 0x80 || super.active.tails & 0x80)
			{
				return "character_palette_scorching_knuckles_normal"
			}
			else
			{
				return "character_palette_burning_knuckles_normal"
			}
		}
	}
	*/
}

// Load Knux' palette into RAM as HSL for palette shenanigans
// In the RGB Knux mod, this will also check for mods w/ RGB Knux compatibility,
// but since FQ isn't that I'll forgo the checks for now
function void loadCharacterPalette(u8 character, u32 targetAddress, u8 paletteVariant)
{
	// Run the vanilla palette loading code
	base.loadCharacterPalette(character, targetAddress, paletteVariant)

	// The vanilla palette loading code uses shared memory to store colors,
	// so we can use this to easily convert all of Knux' colors to HSL
	if(character == CHARACTER_KNUCKLES)
	{
		// Normal palette
		if(!paletteVariant)
		{
			for (u8 i = 0; i < 0x20; ++i)
			{
				u32 rgba = u32[0x800000 + i * 4]
				u32[FlameQuest.RGB_KNUX_PALETTE + i * 4] = FlameQuest.Util.abgrToHSL(rgba)
			}
		}
		// Underwater palette
		else
		{
			for (u8 i = 0; i < 0x20; ++i)
			{
				u32 rgba = u32[0x800000 + i * 4]
				u32[FlameQuest.RGB_KNUX_PALETTE_WATER + i * 4] = FlameQuest.Util.abgrToHSL(rgba)
			}
		}
	}

}
