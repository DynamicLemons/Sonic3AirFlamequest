global bool FastAfterImages //Note: Not actually a timer

//# address-hook(0x010bba) end(0x010c8e)
function void Character.UpdateNormalState.Sonic()
{
	if (updateDebugModeInput(false))
		return

	if (player1.control_override == 0)
	{
		// Set player 1 control state
		control.player1 = control.pad1
	}

	if (char.control_flags & 0x01)
	{
		// Character is not directly controllable (but may be indirectly via an object, like when hanging on a pole or similar)
		char.double_jump_state = 0
	}
	else
	{
		// Call update function depending on flags
		pushA456()
		if (char.flags & char.flag.IN_AIR)
		{
			if (char.flags & char.flag.ROLLING)
				Character.UpdateSonicRollingInAir()
			else
				Character.UpdateSonicUprightInAir()
		}
		else
		{
			if (char.flags & char.flag.ROLLING)
				Character.UpdateSonicRollingOnGround()
			else
				Character.UpdateSonicUprightOnGround()
		}
		popA456()
	}

#if STANDALONE
	if (Game.getSetting(SETTING_DROPDASH) && !competition_mode.active)
	{
		if (sonic.dropdash_counter > 0)
		{
			// Check if hit the ground with drop dash charged
			if ((sonic.dropdash_counter == DROPDASH_FULLCHARGE) && (char.flags & char.flag.IN_AIR) == 0)
			{
				if (char.state != char.state.WIN_POSE)		// This check is only needed for drop dash vs. win pose after FBZ 2 boss
				{
					releaseDropDash()
				}
				else
				{
					// Abort drop dash (e.g. when jumping on a spring)
					sonic.dropdash_counter = 0
				}
			}
			else
			{
				u8 expectedState = (sonic.dropdash_counter < DROPDASH_FULLCHARGE) ? char.state.ROLLING : char.state.SONIC_DROPDASH
				if (char.state != expectedState)
				{
					// Abort drop dash (e.g. when jumping on a spring)
					sonic.dropdash_counter = 0
				}
			}
		}
	}

	if (Game.getSetting(SETTING_SUPERFAST_RUNANIM) && !super.active && abs(char.groundspeed) >= 0x0d00)
	{
		sonic.fastrunanim.timer = 30
	}
	else if (sonic.fastrunanim.timer > 0)
	{
		if (abs(char.groundspeed) >= 0x0800)
			--sonic.fastrunanim.timer
		else
			sonic.fastrunanim.timer = 0
	}

	if (abs(char.groundspeed) >= 0x0a00)
	{
		FastAfterImages = 30
	}
	else
	{
		FastAfterImages = 0
	}
#endif

	if (level.vertical_wrap == 0xff00)
	{
		char.position.y.u16 &= level.height.bitmask
	}

	Character.updateBonusEffects()
	Character.UpdateRingsInSuperForm()
	Character.WriteToPositionBackup()
	Character.checkForWaterSurface()

	char.angle_sensor_1 = u8[0xfffff768]
	char.angle_sensor_2 = u8[0xfffff76a]

	if (u8[0xfffff7c8] != 0)
	{
		if (char.state == char.state.RUNNING)
			char.state = char.state.former
	}

	if ((char.control_flags & 0x02) == 0)	// Hanging flag
	{
		UpdateSonicAnimation()
		if (global.inv_gravity)
		{
			char.render_flags ^= render_flag.FLIP_Y
		}
		UpdateSonicSpritePatterns()
	}

	if ((char.control_flags & 0xa0) == 0)
	{
		Character.CheckCollisionsWithDynamicObjects()
	}
	//////////////
	// GIMMICKS //
	/////////////

	// Super heat effect //

	if (global.zone_act.apparent == 0x0701) || (global.zone_act.apparent == 0x0901)
	{
		if (level.framecounter & 0x01)
		{
			UpdateScreenShake()
			camera.hyper_knux_shake = 0x1
			camera.screenshake.state = 0x1
		}
	}

	// HCZ //

	if (global.zone_act.apparent == 0x0100) || (global.zone_act.apparent == 0x0101)
	{
		if (level.framecounter.low == 0xb4) && (DevToolsHCZRingDrain == 1)
		{
			if (char.flags & char.flag.UNDERWATER) && (ring_counter > 0)
			{
				--ring_counter

			}
		}
	}

	// FBZ //

	if (global.zone_act.apparent == 0x0400)
	{
		if (level.framecounter & 0x384)
		{
			UpdateScreenShake()
			camera.hyper_knux_shake = 0x7
			camera.screenshake.state = 0x7
		}
	}

	if (global.zone_act.apparent == 0x0401)
	{
		if (level.framecounter & 0x02)
		{
			UpdateScreenShake()
			camera.hyper_knux_shake = 0x1
			camera.screenshake.state = 0x1
		}
	}
}


//# address-hook(0x0137c4) end(0x0138f4)
function void Character.UpdateNormalState.Tails()
{
	if (updateDebugModeInput(true))
		return

	if (A0 == 0xffffb000)
	{
		// Tails is the main player
		if (player1.control_override == 0)
		{
			control.tails = control.pad1
			control.player1 = control.pad1
			if (tails.ai_routine >= 0x1a && competition_mode.active == 0)
			{
				Character.TailsAI.Update()
			}
		}
		else
		{
			control.tails = control.player1
		}
	}
	else
	{
		// Tails is the second player
		if (player2.control_override == 0)
		{
			control.tails = control.player2
		}

		if (player2.control_override >= 0 && competition_mode.active == 0)
		{
			Character.TailsAI.Update()
		}
	}

	if (char.control_flags & 0x01)
	{
		// Character is not directly controllable (but may be indirectly via an object, like when hanging on a pole or similar)
		char.double_jump_state = 0
		if (tails.carrying)
		{
			A1 = 0xffffb000
			objA1.flags2a |= char.flag.IN_AIR
			u8[A1 + 0x2e] = 0
			tails.carrying = 0
			tails.catch_timeout = 0
		}
	}
	else
	{
		// Call update function depending on flags
		pushA456()
		if (char.flags & char.flag.IN_AIR)
		{
			if (char.flags & char.flag.ROLLING)
				Character.UpdateTailsRollingInAir()
			else
				Character.UpdateTailsUprightInAir()
		}
		else
		{
			if (char.flags & char.flag.ROLLING)
				Character.UpdateTailsRollingOnGround()
			else
				Character.UpdateTailsUprightOnGround()
		}
		popA456()
	}

	if (level.vertical_wrap == 0xff00)
	{
		char.position.y.u16 &= level.height.bitmask
	}

	Character.updateBonusEffects()
	Character.UpdateRingsInSuperForm()
	Character.WriteToPositionBackup()
	Character.checkForWaterSurface()

	char.angle_sensor_1 = u8[0xfffff768]
	char.angle_sensor_2 = u8[0xfffff76a]

	if (u8[0xfffff7c9] != 0)
	{
		if (char.state == 0)
			char.state = char.state.former
	}

	if ((char.control_flags & 0x02) == 0)	// Hanging flag
	{
		UpdateTailsAnimation()
		if (global.inv_gravity)
		{
			char.render_flags ^= render_flag.FLIP_Y
		}
		UpdateTailsSpritePatterns()
	}

	if ((char.control_flags & 0xa0) == 0)
	{
		Character.CheckCollisionsWithDynamicObjects()
	}

	if (abs(char.groundspeed) >= 0x0a00)
	{
		FastAfterImages = 30
	}
	else
	{
		FastAfterImages = 0
	}
}

// RGB Knux & whatever this needs to do for "custom animations"
//# address-hook(0x01656c) end(0x016640)
function void Character.UpdateNormalState.Knuckles()
{
	// Handle RGB Knux stuff here. Might not be the best place to do it,
	// but it'll be fine here for now
	if(FlameQuest.Secret.useRGBKnux)
	{
		FlameQuest.Character.updateRGBKnux()
	}

	if (updateDebugModeInput(false))
		return

	if (player1.control_override == 0)
	{
		// Set player 1 control state
		control.player1 = control.pad1
	}

	if (char.control_flags & 0x01)
	{
		// Character is not directly controllable (but may be indirectly via an object, like when hanging on a pole or similar)
		char.double_jump_state = 0
	}
	else
	{
		// Call update function depending on flags
		pushA456()
		if (char.flags & char.flag.IN_AIR)
		{
			if (char.flags & char.flag.ROLLING)
				Character.UpdateKnucklesRollingInAir()
			else
				Character.UpdateKnucklesUprightInAir()
		}
		else
		{
			if (char.flags & char.flag.ROLLING)
				Character.UpdateKnucklesRollingOnGround()
			else
				Character.UpdateKnucklesUprightOnGround()
		}
		popA456()
	}

	if (level.vertical_wrap == 0xff00)
	{
		char.position.y.u16 &= level.height.bitmask
	}

	Character.updateBonusEffects()
	Character.UpdateRingsInSuperForm()
	Character.WriteToPositionBackup()
	Character.checkForWaterSurface()

	char.angle_sensor_1 = u8[0xfffff768]
	char.angle_sensor_2 = u8[0xfffff76a]

	if (u8[0xfffff7c8] != 0)
	{
		if (char.state == char.state.RUNNING)
			char.state = char.state.former
	}

	if ((char.control_flags & 0x02) == 0)	// Hanging flag
	{
		UpdateKnucklesAnimation()
		if (global.inv_gravity)
		{
			char.render_flags ^= render_flag.FLIP_Y
		}
		UpdateKnucklesSpritePatterns()
	}

	if ((char.control_flags & 0xa0) == 0)
	{
		Character.CheckCollisionsWithDynamicObjects()
	}

	if (abs(char.groundspeed) >= 0x0a00)
	{
		FastAfterImages = 1
	}
	else
	{
		FastAfterImages = 0
	}
}

// Function that (probably) updates slot machine characters
//# address-hook(0x04b958) end(0x04b978)
function void fn04b958()
{
	if(getMainCharacter() == CHARACTER_KNUCKLES && FlameQuest.Secret.useRGBKnux)
	{
		FlameQuest.Character.updateRGBKnux()
	}

	control.player1 = control.pad1
	if (debug_mode.state)
	{
		DebugMode.BaseUpdate()
		fn04bbf4()
	}
	else
	{
		// Targets:
		//  - 0x04b9ce	-> objA0.base_state = 0x00
		//  - 0x04ba4e	-> objA0.base_state = 0x02
		//  - 0x04bc1e	-> objA0.base_state = 0x04
		call tableLookupAddress(0x04b9bc, objA0.base_state)

		fn04b97c()
	}
}


// Function that updates RGB Knux
function void FlameQuest.Character.updateRGBKnux()
{
	#if !GAMEAPP
	debugLog("Using RGB Knux")
	#endif

	FlameQuest.Character.updateSuperRGBKnux()

	for(u8 i = 1; i < 32; i++)
	{
		// Choose how much to shift the color by
		u16 shiftDegree = super.active == 0xff ? 8 : (super.active ? 4 : 1)

		// Shift current color
		u32[FlameQuest.RGB_KNUX_PALETTE + i * 4] = DKoC.Util.shiftHSL(u32[FlameQuest.RGB_KNUX_PALETTE + i * 4], shiftDegree)

		// Get current color & apply any RGB Knux luminance shifting
		u32 hslColor = u32[FlameQuest.RGB_KNUX_PALETTE + i * 4]

		hslColor = DKoC.Util.modifyHSLLuminance(hslColor, FlameQuest.RGBKnux.superGlowOffset)

		// Convert color to RGB
		u32 rgbColor = DKoC.Util.hslToABGR(hslColor)

		u16[0x802080 + i * 2] = packColor(rgbColor)

		// Renderer.setPaletteEntry(0x80 + i, rgbColor)
	}

	// Underwater Knux
	for(u8 i = 1; i < 32; i++)
	{
		// Choose how much to shift the color by
		u16 shiftDegree = super.active == 0xff ? 8 : (super.active ? 4 : 1)

		// Shift current color
		u32[FlameQuest.RGB_KNUX_PALETTE_WATER + i * 4] = DKoC.Util.shiftHSL(u32[FlameQuest.RGB_KNUX_PALETTE_WATER + i * 4], shiftDegree)

		// Convert color to RGB
		u32 rgbColor = DKoC.Util.hslToABGR(u32[FlameQuest.RGB_KNUX_PALETTE_WATER + i * 4])


		u16[0x802380 + i * 2] = packColor(rgbColor)

		// Renderer.setPaletteEntry(0x80 + i, rgbColor)
	}
}

// Update Super RGB Knux specific stuff (i.e. palettes)
function void FlameQuest.Character.updateSuperRGBKnux()
{
	// Update RGB Knux' super glow
	if(super.active)
	{
		if(FlameQuest.RGBKnux.superGlowIsIncreasing)
			FlameQuest.RGBKnux.superGlowOffset += (super.active == 0xff ? 6 : 3)
		else
			FlameQuest.RGBKnux.superGlowOffset -= (super.active == 0xff ? 6 : 3)
		/*
		FlameQuest.RGBKnux.superGlowOffset = abs(0x67 - super.palettefx.frame)

		if(super.active != 0xff)
			FlameQuest.RGBKnux.superGlowOffset /= 2
		*/

		// Prevent glow offset from becoming too large (or small)
		FlameQuest.RGBKnux.superGlowOffset = clamp(FlameQuest.RGBKnux.superGlowOffset, 0, 64)

		// If either boundary was hit, switch between increasing/decreasing mode
		if(FlameQuest.RGBKnux.superGlowOffset == 64)
		{
			FlameQuest.RGBKnux.superGlowIsIncreasing = false
		}
		else if(FlameQuest.RGBKnux.superGlowOffset == 0)
		{
			FlameQuest.RGBKnux.superGlowIsIncreasing = true
		}
	}
	else
	{
		if(FlameQuest.RGBKnux.superGlowOffset)
		{
			FlameQuest.RGBKnux.superGlowOffset -= 3

			if(FlameQuest.RGBKnux.superGlowOffset < 0)
				FlameQuest.RGBKnux.superGlowOffset = 0
		}
	}
}
